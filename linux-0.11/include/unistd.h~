#ifndef _UNISTD_H
#define _UNISTD_H

/* ok, this may be a joke, but I'm working on it */
#define _POSIX_VERSION 198808L

#define _POSIX_CHOWN_RESTRICTED/* only root can do a chown (I think..) */
#define _POSIX_NO_TRUNC/* no pathname truncation (but see in kernel) */
#define _POSIX_VDISABLE '\0'/* character to disable things like ^C */
/*#define _POSIX_SAVED_IDS *//* we'll get to this yet */
/*#define _POSIX_JOB_CONTROL *//* we aren't there quite yet. Soon hopefully */

#define STDIN_FILENO0
#define STDOUT_FILENO1
#define STDERR_FILENO2

#ifndef NULL
#define NULL    ((void *)0)
#endif

/* access */
#define F_OK0
#define X_OK1
#define W_OK2
#define R_OK4

/* lseek */
#define SEEK_SET0
#define SEEK_CUR1
#define SEEK_END2

/* _SC stands for System Configuration. We don't use them much */
#define _SC_ARG_MAX1
#define _SC_CHILD_MAX2
#define _SC_CLOCKS_PER_SEC3
#define _SC_NGROUPS_MAX4
#define _SC_OPEN_MAX5
#define _SC_JOB_CONTROL6
#define _SC_SAVED_IDS7
#define _SC_VERSION8

/* more (possibly) configurable things - now pathnames */
#define _PC_LINK_MAX1
#define _PC_MAX_CANON2
#define _PC_MAX_INPUT3
#define _PC_NAME_MAX4
#define _PC_PATH_MAX5
#define _PC_PIPE_BUF6
#define _PC_NO_TRUNC7
#define _PC_VDISABLE8
#define _PC_CHOWN_RESTRICTED9

#include <sys/stat.h>
#include <sys/times.h>
#include <sys/utsname.h>
#include <utime.h>

#ifdef __LIBRARY__

#define __NR_setup0/* used only by init, to get system going */
#define __NR_exit1
#define __NR_fork2
#define __NR_read3
#define __NR_write4
#define __NR_open5
#define __NR_close6
#define __NR_waitpid7
#define __NR_creat8
#define __NR_link9
#define __NR_unlink10
#define __NR_execve11
#define __NR_chdir12
#define __NR_time13
#define __NR_mknod14
#define __NR_chmod15
#define __NR_chown16
#define __NR_break17
#define __NR_stat18
#define __NR_lseek19
#define __NR_getpid20
#define __NR_mount21
#define __NR_umount22
#define __NR_setuid23
#define __NR_getuid24
#define __NR_stime25
#define __NR_ptrace26
#define __NR_alarm27
#define __NR_fstat28
#define __NR_pause29
#define __NR_utime30
#define __NR_stty31
#define __NR_gtty32
#define __NR_access33
#define __NR_nice34
#define __NR_ftime35
#define __NR_sync36
#define __NR_kill37
#define __NR_rename38
#define __NR_mkdir39
#define __NR_rmdir40
#define __NR_dup41
#define __NR_pipe42
#define __NR_times43
#define __NR_prof44
#define __NR_brk45
#define __NR_setgid46
#define __NR_getgid47
#define __NR_signal48
#define __NR_geteuid49
#define __NR_getegid50
#define __NR_acct51
#define __NR_phys52
#define __NR_lock53
#define __NR_ioctl54
#define __NR_fcntl55
#define __NR_mpx56
#define __NR_setpgid57
#define __NR_ulimit58
#define __NR_uname59
#define __NR_umask60
#define __NR_chroot61
#define __NR_ustat62
#define __NR_dup263
#define __NR_getppid64
#define __NR_getpgrp65
#define __NR_setsid66
#define __NR_sigaction67
#define __NR_sgetmask68
#define __NR_ssetmask69
#define __NR_setreuid70
#define __NR_setregid71
#define __NR_sem_open 72
#define __NR_sem_wait73
#define __NR_sem_post74
#define __NR_sem_unlink 75
#define __NR_shmget 76
#define __NR_shmat 77

#define QUE_LEN 16
#define SEM_FAILED  (void*) 0
struct semaphore_queue
{
        int front;
            int rear;
                struct task_struct *wait_tasks[QUE_LEN];

};
typedef struct semaphore_queue sem_queue;

struct semaphore_t
{
        int value;
            int occupied;
                char name[16];
                    struct semaphore_queue wait_queue;

};
typedef struct semaphore_t sem_t;

#define _syscall0(type,name) \
    type name(void) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
            : "=a" (__res) \
            : "0" (__NR_##name)); \
if (__res >= 0) \
    return (type) __res; \
errno = -__res; \
return -1; \
}

#define _syscall1(type,name,atype,a) \
    type name(atype a) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
            : "=a" (__res) \
            : "0" (__NR_##name),"b" ((long)(a))); \
if (__res >= 0) \
    return (type) __res; \
errno = -__res; \
return -1; \
}

#define _syscall2(type,name,atype,a,btype,b) \
    type name(atype a,btype b) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
            : "=a" (__res) \
            : "0" (__NR_##name),"b" ((long)(a)),"c" ((long)(b))); \
if (__res >= 0) \
    return (type) __res; \
errno = -__res; \
return -1; \
}

#define _syscall3(type,name,atype,a,btype,b,ctype,c) \
    type name(atype a,btype b,ctype c) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
            : "=a" (__res) \
            : "0" (__NR_##name),"b" ((long)(a)),"c" ((long)(b)),"d" ((long)(c))); \
if (__res>=0) \
    return (type) __res; \
errno=-__res; \
return -1; \
}

#endif /* __LIBRARY__ */

extern int errno;

int access(const char * filename, mode_t mode);
int acct(const char * filename);
int alarm(int sec);
int brk(void * end_data_segment);
void * sbrk(ptrdiff_t increment);
int chdir(const char * filename);
int chmod(const char * filename, mode_t mode);
int chown(const char * filename, uid_t owner, gid_t group);
int chroot(const char * filename);
int close(int fildes);
int creat(const char * filename, mode_t mode);
int dup(int fildes);
int execve(const char * filename, char ** argv, char ** envp);
int execv(const char * pathname, char ** argv);
int execvp(const char * file, char ** argv);
int execl(const char * pathname, char * arg0, ...);
int execlp(const char * file, char * arg0, ...);
int execle(const char * pathname, char * arg0, ...);
volatile void exit(int status);
volatile void _exit(int status);
int fcntl(int fildes, int cmd, ...);
int fork(void);
int getpid(void);
int getuid(void);
int geteuid(void);
int getgid(void);
int getegid(void);
int ioctl(int fildes, int cmd, ...);
int kill(pid_t pid, int signal);
int link(const char * filename1, const char * filename2);
int lseek(int fildes, off_t offset, int origin);
int mknod(const char * filename, mode_t mode, dev_t dev);
int mount(const char * specialfile, const char * dir, int rwflag);
int nice(int val);
int open(const char * filename, int flag, ...);
int pause(void);
int pipe(int * fildes);
int read(int fildes, char * buf, off_t count);
int setpgrp(void);
int setpgid(pid_t pid,pid_t pgid);
int setuid(uid_t uid);
int setgid(gid_t gid);
void (*signal(int sig, void (*fn)(int)))(int);
int stat(const char * filename, struct stat * stat_buf);
int fstat(int fildes, struct stat * stat_buf);
int stime(time_t * tptr);
int sync(void);
time_t time(time_t * tloc);
time_t times(struct tms * tbuf);
int ulimit(int cmd, long limit);
mode_t umask(mode_t mask);
int umount(const char * specialfile);
int uname(struct utsname * name);
int unlink(const char * filename);
int ustat(dev_t dev, struct ustat * ubuf);
int utime(const char * filename, struct utimbuf * times);
pid_t waitpid(pid_t pid,int * wait_stat,int options);
pid_t wait(int * wait_stat);
int write(int fildes, const char * buf, off_t count);
int dup2(int oldfd, int newfd);
int getppid(void);
pid_t getpgrp(void);
pid_t setsid(void);

#endif
